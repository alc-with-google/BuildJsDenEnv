/*************
AGENDA
************/
Minification - to speed page loads
Sourcemaps - support debugging in production
Dynamic HTML - production specific concerns
Cache busting - user receive the latest version of the code upon deployment
Bundle splitting - user dont have to download all the application for minor changes.
Error logging - when bug sneak into production

/*************
Minification
************/
{
    Shortens variable and function names
    Removes comments
    Removes whitespace and new lines
    Dead code elimination / Tree-shaking
    Debug via sourcemap
}
/*************
DEMO: Production Webpack Configuration with Minification
************/

//create Webpack.config.prod.js
// the UglifyJsPlugin does the minification
// it's imported via webpack and used as a plugin.
// the DudupePlugin is also used to eliminate duplicate packages when generating the bundle.

{
  import path from 'path';
  import webpack from "webpack";

  export default {
    debug: true,
    devtool: 'source-map', // recommeded for productiom, this specifes how source would be generated; so we can original code even after minificatuion
    noInfo: false,
    entry: [
      path.resolve(__dirname, 'src/index')
    ],
    target: 'web',
    output: {
      path: path.resolve(__dirname, 'dist'), // where to write the output.
      publicPath: '/',
      filename: 'bundle.js'
    },
    plugins: [
      //Eliminate duplicate packages when generating bundle
      new webpack.optimize.DedupePlugin(),

      //Minify JS
      new webpack.optimize.UglifyJsPlugin(),
    ],
    module: {
      loaders: [
        {test: /\.js$/, exclude: /node_modules/, loaders: ['babel']},
        {test: /\.css$/, loaders: ['style','css']}
      ]
    }
  };
}

//then write a script (buildScripts/build.js) that run the webpack build for production.
{
    /*eslint-disable no-console */
    import webpack from 'webpack';
    import webpackConfig from '../webpack.config.prod';
    import chalk from 'chalk';

    process.env.NODE_ENV = 'production';
    // (optional for here.), important if you create a dev specific config for babel in .babelrc file
    // babel and other libraries look for for this variable to determine how they are built

    webpack(webpackConfig).run((err, stats) => {
    if (err) {//so a fatal error occrued here.
        console.log(chalk.red(err));
        return 1;
    }
    const jsonStats = stats.toJson();

    if (jsonStats.hasErrors) {
        return jsonStats.errors.map(error => console.log(chalk.red(error)));
    }

    if (jsonStats.hasWarnings) {
        console.log(chalk.yellow('Webpack generated the following warnings: '));
        jsonStats.warnings.map(warning => console.log(chalk.yelllow(warning)));
    }

    console.log(`Webpack stats: ${stats}`);

    //if we get this far, the build succeeded.
    console.log(chalk.green('Your app has been built for production and written to /dist!'))

    return 0;
    });

}



/******************************
NOT FOR USE IN ACTUAL PRODUCTION USE.
distServer.js is just useful for hosting the minifed production build for
local debugging puposes.

Then we can move files to serve them on some host

How to run the final production version of the app in my local machine
just to make sure everything looks good
******************************/

{
  import express from 'express';
  import path from 'path';
  import open from 'open';
  import compression from 'compression';

  /*eslint-disable no-console */

  const port = 3000;
  const app = express();

  //enable gzip, to see size
  app.use(compression());


  //support to express for serving static files
  app.use(express.static('dist'));

  // index.html comes from the dist server rather from the src folder
  app.get ('/', function (req, res){
      res.sendFile(path.join(__dirname, '../dist/index.html'));
  });

  app.listen(port, function(err){
      if (err){
          console.log(err);
      } else {
          open('http://localhost:' + port)
      }
  });

}

// what production api should you use
{
  export default function getBaseUrl (){
    return getQueryStringParameterByName('useMockApi') ? 'http://localhost:3001/' : 'https://shrouded-refuge-41310.herokuapp.com/';
  }

  function getQueryStringParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
  }

}

/**************
npm scripts to automate the production build scripts.
**************/
{
  "clean-dist": "rimraf ./dist && mkdir dist",
  "prebuild": "npm-run-all clean-dist test lint",
  "build": "babel-node buildScripts/build.js",
  "postbuild": "babel-node buildScripts/distServer.js",
}
